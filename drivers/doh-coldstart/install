#!/usr/bin/perl

use strict;
use warnings;
use Cwd;
use FindBin qw($RealBin);
#use File::Spec::Functions qw(rel2abs);

use lib "$RealBin/../../tools/cth-utils";
use CthUtils;

$| = 1;  # Turn on auto-flush for STDOUT (Perl doesn't do this by default)

# ---------------------------------------------------------------------------
# Global vars
# ---------------------------------------------------------------------------

my $driver = "doh-coldstart";

my $source_dir = "../../local/doh-contracts"; # source dir with the template

my $run_build_sh = "run-build.sh";

# build list of local directories for all supported targets
my @targets = ("prod", "staging", "dev", "test", "debug");
my %local_dir;
foreach my $tg (@targets) { $local_dir{$tg} = "../../local/$tg/doh-contracts"; }

my $target = "test"; # default target is the test target (hg3/tc3)

# ---------------------------------------------------------------------------
# Utils
# ---------------------------------------------------------------------------

# change to driver dir
sub chdir_driver_dir {
    #chdir($RealBin) or die "ERROR: $driver: Failed to change working directory: $!";
    chdir_for_sure($RealBin);
}

sub chdir_target_dir {
    my $tg = shift;
    die "ERROR: doh-coldstart: chdir_target_dir target not defined" unless (defined $tg);
    chdir_driver_dir();    # absolute

    #chdir $local_dir{$tg};
    #print "Current working directory: " . getcwd() .  "\n";
    chdir_for_sure($local_dir{$tg});
}

# target is prod, staging, dev, test, debug
sub copy_doh {
    my $target = shift;
    die "ERROR: doh-coldstart: copy target not defined" unless (defined $target);

    my $destination = "../../local/$target/";

    my $to_remove = $destination . "doh-contracts";

    if (-d $to_remove) {
        system("rm -rf $destination") == 0 or die "ERROR: doh-coldstart: Error while trying to clear old local copy of doh_contracts for target $target ('rm -rf $to_remove'): $!";
    }
    system("mkdir -p $destination") == 0 or die "ERROR: doh-coldstart: Failed to create target directory $destination: $!";
    system("cp -r $source_dir $destination") == 0 or die "ERROR: doh-coldstart: Failed to copy $source_dir to $destination: $!";
}

# ---------------------------------------------------------------------------
# First, we need to parse arguments passed to this install script.
# ---------------------------------------------------------------------------

use lib "$RealBin/../../tools/cth-goodies";
use CthGoodies;

my ($switches, $options) = cth_standard_args_parser("", "target doh");

# ---------------------------------------------------------------------------
# Take a -o target=xxx option that will tell which one we want to compile
#   (or to install --doh <dir> into).
# ---------------------------------------------------------------------------

if (defined $options->{'target'}) {
    if ($options->{'target'} eq 'hgm' || $options->{'target'} eq 'prod') {
        $target = 'prod';
    } elsif ($options->{'target'} eq 'hg1' || $options->{'target'} eq 'staging') {
        $target = 'staging';
    } elsif ($options->{'target'} eq 'hg2' || $options->{'target'} eq 'dev') {
        $target = 'dev';
    } elsif ($options->{'target'} eq 'hg3' || $options->{'target'} eq 'test') {
        $target = 'test';
    } elsif ($options->{'target'} eq 'hg4' || $options->{'target'} eq 'debug') {
        $target = 'debug';
    } else {
        die "ERROR: doh-hotstart start: unknown target: '" . $options->{'target'} . "'.";
    }
}

# ---------------------------------------------------------------------------
# Go to the driver dir
# ---------------------------------------------------------------------------

chdir_driver_dir();

# ---------------------------------------------------------------------------
# Check if we are going to skip download and compilation, and instead fetch
#   a local DoH tree that's already compiled.
#
# The option -o doh=<directory> allows the user (e.g. via cth --run or
#   cth -i) instruct the doh-coldstart driver to take the given directory,
#   which should be a fully set-up version of the DoH source code that's
#   already fully compiled to wasm/abi files, and then copy its contents
#   to the correct local/doh-coldstart/... directory where this driver
#   would be instead download the DoH source code and compiling it.
# The given directory must either be an absolute path or a path relative to
#   this driver's directory.
# ---------------------------------------------------------------------------

if (defined $options->{'doh'}) {

    my $doh_dir = $options->{'doh'};
    if (!-d $doh_dir) {
        print "ERROR: doh-coldstart install: given --doh directory not found (must be absolute or relative to " . getcwd() . "): '$doh_dir': $!\n";
    }
    #my $abs_doh_dir = rel2abs($doh_dir); # in the odd case it's relative
    my $abs_doh_dir = absolute($doh_dir, CthUtils::ABSOLUTE_MUST_EXIST);

    #my $destination = "../../local/$target";
    # find the absolute path since we will be printing this and relative paths are confusing
    #my $abs_destination = rel2abs($destination);

    my $abs_destination = absolute("../../local/$target", CthUtils::ABSOLUTE_MAY_NOT_EXIST);

    # doh-contracts is part of it
    $abs_destination = $abs_destination . "/doh-contracts";

    # clear the target dir if needed
    if (-d $abs_destination) {
        print "doh-coldstart install: deleting /local destination directory: '$abs_destination' ...\n";
        system("rm -rf $abs_destination") == 0 or die "ERROR: doh-coldstart: Error while trying to clear old local copy of doh_contracts for target $target ('rm -rf $abs_destination'): $!";
    }

    # recreate the destination with an empty doh-contracts (which is expected)
    print "doh-coldstart install: creating /local destination directory: '$abs_destination' ...\n";
    system("mkdir -p $abs_destination") == 0 or die "ERROR: doh-coldstart: Failed to create target directory '$abs_destination': $!";

    # copy the *files* within the given doh_dir into a "doh-contracts" directory
    print "doh-coldstart install: copying all files inside given --doh directory '$abs_doh_dir'(/*) into '$abs_destination' ...\n";
    system("cp -r $abs_doh_dir/* $abs_destination") == 0 or die "ERROR: doh-coldstart: Failed to copy everything inside '$abs_doh_dir' to '$abs_destination': $!";

    print "doh-coldstart install: given DoH source/binaries installed successfully.\n";

    # success
    exit 0;
}

# ---------------------------------------------------------------------------
# We need to download the DoH source code, since it is no longer
#   a submodule. This is done by tools/get-doh/get-doh.sh.
# ---------------------------------------------------------------------------

print "$driver: Downloading latest DoH source code to $source_dir using tools/get-doh.sh\n";

system("../../tools/get-doh/get-doh.sh $source_dir") == 0 or die "ERROR: doh-coldstart: Failed to get DoH source code: $!";

# ---------------------------------------------------------------------------
# The doh-contracts assembled by get-doh.sh is a CODE TEMPLATE. It is not actual
#   source code for the DoH contracts suite. It has to be preprocessed for
#   ALL DoH targets to produce several different DoH contract suites that are
#   specific to each target.
#
# This driver will only build one target, which is "test" (hg3/tc3).
# Ideally, we'd build and test only the production target: we'd like to
#   test the version of the game that is actually deployed. The various
#   targets were invented to facilitate humans and human-interactive
#   shell scripts testing vs. a shared remote game deployment.
# On the other hand, automated testing is (mostly) run against a local
#   blockchain node with the deployed game, with full control of setting
#   objects (setplayer, etc.), the RNG and clock. The added convenience
#   of having more forgiving game constants is more of a hindrance than
#   a help for automated testing, though its great for people-testers
#   and shared blockchain/contracts remote testing.
# It's still contentions whether we want to enable clock and RNG for
#   the production constants/content, which would allow automated testing
#   (I don't remember why exactly this was disabled and how right now),
#   so as discussed we'll write automated tests for the test (hg3/tc3)
#   target for now.
# ---------------------------------------------------------------------------

print "$driver: Checking for doh-contracts at $source_dir\n";

if (-e "$source_dir/$run_build_sh") {
    print "$driver: DoH contracts found.\n";
} else {
    print "$driver: ERROR: DoH contracts not found in the expected tools directory path.\n";
    exit 1;
}

# ---------------------------------------------------------------------------
# Create a DoH source code copy for each compilation target
#
# Copy the tools/doh-contracts template to:
#   local/prod/doh-contracts/
#   local/staging/doh-contracts/
#   local/dev/doh-contracts/
#   local/test/doh-contracts/
#   local/debug/doh-contracts/
# ---------------------------------------------------------------------------

print "$driver: Copying contract templates to local/ for all DoH targets ...\n";

foreach my $tg (@targets) {
    copy_doh($tg);
}

# ---------------------------------------------------------------------------
# Customize contract source code for each compilation target
#
#   local/prod/doh-contracts/set-prod.sh
#   local/staging/doh-contracts/set-staging.sh
#   local/dev/doh-contracts/set-dev.sh
#   local/test/doh-contracts/set-test.sh
#   local/test/doh-contracts/set-debug.sh
# ---------------------------------------------------------------------------

print "$driver: Instantiating contract templates on local/ for all DoH targets ...\n";

foreach my $tg (@targets) {
    chdir_target_dir($tg);
    system("./set-$tg.sh") == 0 or die "ERROR: $driver: Failed to create '$tg' contracts: $!";
}

# ---------------------------------------------------------------------------
# Compile DoH
#
# Currently, the test system compiles only the test target:
#
#   local/test/doh-contracts/
# ---------------------------------------------------------------------------

my $ret;

print "$driver: ************************************************************************************************\n";
print "$driver: *** SKIPPING COMPILATION of all DoH targets that are not the test (hg3/tc3) target!!!\n";
print "$driver: *** Tests that try to run with any target other than the test target will fail.\n";
print "$driver: ************************************************************************************************\n";

# *************************************************************************************************************
# Compile DoH contracts
# FIXME/TODO: Redo with fork/wait (see cth parallel test execution code)
# *************************************************************************************************************

my $cpus = `lscpu -b -p=Core,Socket | grep -v '^#' | sort -u | wc -l`;
chomp($cpus);
if (!defined $cpus || !($cpus =~ /^\d+$/)) {
    print "WARNING: Can't retrieve number of cpu cores; will assume only 1 core.\n";
    $cpus = 1;
}

# ***********************
# FIXME/REMOVE:
$cpus = 1;  # Getting some weird crashes, so disabling parallel compilation for now
# ***********************

print "Detected $cpus processors available to build DoH contracts.\n";

if ($target ne 'test') {
    print "WARNING: doh-colstart install: caller specified '--target $target' but this will be unused/ignored since --doh <dir> was not also used. When doh-coldstart compiles contracts, it always compiles the 'test' target.\n";
}
print "Building DoH for compilation target 'test' (hg3/tc3) ONLY...\n";
chdir_target_dir('test');

use File::Temp qw(tempfile);
use File::Path qw(make_path);

# Find all subdirectories that have a CMakeLists.txt in them (meaning its a compilable contract dir)
opendir(my $dh, '.') or die "ERROR: Could not open current directory: $!";
my @directories = grep { -d "./$_" && ! /^\.{1,2}$/ && -e "./$_/CMakeLists.txt"} readdir($dh);
closedir($dh);
my $total_dirs = scalar @directories;
print "Found $total_dirs contracts to compile.\n";

# Push doh-hegemon-contract to the top since it is the one that takes the longest
my $hegemon_contract = "doh-hegemon-contract";
my $hegemon_index = -1;
for my $i (0 .. $#directories) {
    if ($directories[$i] eq $hegemon_contract) {
        $hegemon_index = $i;
        last;  # Element found, exit the loop
    }
}
if ($hegemon_index >= 0) {
    splice(@directories, $hegemon_index, 1);  # Remove the element
    unshift(@directories, $hegemon_contract);  # Add it to the beginning
}

# Print the contract list and clean up the build dirs on each
foreach my $di (@directories) {
    `rm -rf $di/build`;
    print "Contract to compile: $di\n";
}

# Remove the compile error file if any
`rm -f COMPILE_ERROR`;

# Create a temporary directory to hold task files
# If it exists, get rid of it
my $task_dir = 'task_files';
`rm -rf $task_dir`;
make_path($task_dir);

# Create a global lock file
# If it exists, get rid of it
my $lock_file = 'lock_file';
`rm -f $lock_file`;
open(my $lock_fh, '>', $lock_file) or die "Could not create lock file: $!";
close($lock_fh);  # Close the lock file

# Create task files for each directory
for my $i (0 .. $total_dirs - 1) {
    my $dir = $directories[$i];
    my $task_file = "$task_dir/task_$i";
    open(my $fh, '>', $task_file) or die "Could not create task file: $!";
    print $fh $dir;
    close($fh);
}

# Fork processes
for my $i (0 .. $cpus - 1) {
    print "doh-coldstart: install: compiler child process " . ($i+1) . "/$cpus starting.\n";

    my $pid;
    if ($cpus == 1) {
        # if only one CPU, just run it here
        $pid = 0;
    } else {
        $pid = fork();
        die "ERROR: Failed to fork: $!" unless defined $pid;
    }

    if ($pid == 0) {
        my $child_id = $$;  # Get the PID of the current process

        while (1) {
            # Acquire the global lock before processing the task
            open my $lockfile, ">", "$lock_file" or die "FATAL ERROR: Runner $child_id: Can't acquire lock file: $!";
            flock($lockfile, 2);  # Lock for writing

            my @task_files = glob("$task_dir/task_*");
            my $task_file = shift @task_files;

            if (! defined $task_file) {
                print "Runner $child_id: Can't find a task file (probably there are no more compilation tasks to pick up).\n";
                last;
            }

            my $dir;
            open(my $fh, '<', $task_file) or die "FATAL ERROR: Runner $child_id: Could not read task file: $!";
            $dir = <$fh>;
            close($fh);

            unlink($task_file);  # Remove the task file
            close($lockfile);  # Unlock

            print "Runner $child_id: compiling $dir\n";

            `mkdir -p $dir/build`;

            my $error = 0;

            if (chdir("$dir/build")) {
                my $build_dir = `pwd`;
                chomp($build_dir);
                #print "Runner $child_id: changed to directory: $dir/build\n";
                system("cmake .. > cmake.log 2>&1");
                if ($? != 0) {
                    print "Runner $child_id: COMPILE ERROR: cmake error for '$dir'. Log in $build_dir/cmake.log\n"; # $o
                    $error = 1;
                } else {
                    system("make -j 6 > make.log 2>&1"); # not sure if -j actually buys us anything here... (copypaste)
                    if ($? != 0) {
                        print "Runner $child_id: COMPILE ERROR: make error for '$dir'. Log in $build_dir/make.log\n"; # $o
                        $error = 1;
                    } else {
                        print "Runner $child_id: successfully compiled '$dir'\n";
                    }
                }
                chdir("../..");
            } else {
                print "Runner $child_id: ERROR: Failed to change to directory: $dir - $!\n";
                $error = 1;
            }

            if ($error != 0) {
                open my $lockfile, ">", "$lock_file" or die "FATAL ERROR: Runner $child_id: Can't acquire lock file: $!";
                flock($lockfile, 2);  # Lock for writing

                `echo "$dir" >> COMPILE_ERROR`;

                close($lockfile);  # Unlock
            }
        }

        print "Runner $child_id: done.\n";

        # Don't exit if not actually spawning child processes
        if ($cpus > 1) {
            exit;  # Child process exits
        }
    }
}

# Parent process waits for child processes to finish
for my $i (0 .. $cpus - 1) {
    # If only one cpu, did not actually fork so no need to wait()
    if ($cpus > 1) {
        wait();
    }
    print "doh-coldstart: install: compiler child process " . ($i+1) . "/$cpus finished.\n";
}

`rm -r task_files`;

`rm -f lock_file`;

if (-e 'COMPILE_ERROR') {
    print "ERROR: doh-coldstart: install: DoH source code compilation failed for the following contracts:\n";
    print `cat COMPILE_ERROR`;
    exit 1;
}

print "doh-coldstart: install: Successfully built DoH.\n";
